import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";

/**

Veo 3 Video Generator — Full Stack Template


---

What you get:

1. Frontend (this React component): a clean UI with an API Key field,



prompt input, model options, progress, preview, and download.

2. Backend (Node.js/Express) code is included below as a code block



string you can copy into server.js. It exposes routes:

- POST /api/generate   -> starts a video job

- GET  /api/status/:id -> polls job status

- GET  /api/file/:id   -> streams the finished video

Why a backend? Veo 3 currently requires a server-side call. Putting your

key directly in the browser can expose it and also run into CORS limits.

This template keeps the API key in the browser but **sends it to your own

backend per request**, so you can rotate/validate it, or replace with

service-account auth later without touching the UI.

Hook up the backend, deploy both together, and you're good.\n

NOTE: The backend includes a minimal stub for Veo 3. Replace the marked

TODO section with the actual call to your chosen Veo 3 endpoint (Vertex AI

or Gemini API) and map responses to the unified shape used here. */


// ---------- Simple UI Primitives ---------- const Label = ({ htmlFor, children }) => ( <label htmlFor={htmlFor} className="block text-sm font-medium text-gray-700 mb-1"> {children} </label> );

const Input = (props) => ( <input {...props} className={"w-full rounded-2xl border border-gray-300 px-3 py-2 outline-none focus:ring-2 focus:ring-black/10 shadow-sm " + (props.className || "")} /> );

const Textarea = (props) => (

  <textarea
    {...props}
    className={"w-full rounded-2xl border border-gray-300 px-3 py-2 outline-none focus:ring-2 focus:ring-black/10 shadow-sm min-h-[120px] " +
      (props.className || "")}
  />
);

const Select = (props) => (
  <select
    {...props}
    className={"w-full rounded-2xl border border-gray-300 px-3 py-2 outline-none focus:ring-2 focus:ring-black/10 shadow-sm bg-white " +
      (props.className || "")}
  />
);

const Button = ({ children, className = "", ...props }) => (
  <button
    {...props}
    className={`rounded-2xl px-4 py-2 font-medium shadow-sm border border-black/10 hover:shadow transition ${className}`}
  >
    {children}
  </button>
);

const Card = ({ children, className = "" }) => (
  <div className={`rounded-3xl border border-black/10 p-5 shadow-sm bg-white ${className}`}>{children}</div>
);

// ---------- Helpers ----------
const prettyBytes = (bytes) => {
  if (!Number.isFinite(bytes)) return "-";
  const units = ["B", "KB", "MB", "GB"]; let i = 0;
  while (bytes >= 1024 && i < units.length - 1) { bytes /= 1024; i++; }
  return `${bytes.toFixed(1)} ${units[i]}`;
};

const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

// ---------- Main Component ----------
export default function App() {
  const [apiKey, setApiKey] = useState("");
  const [prompt, setPrompt] = useState("");
  const [negativePrompt, setNegativePrompt] = useState("");
  const [duration, setDuration] = useState(5);
  const [aspect, setAspect] = useState("9:16");
  const [seed, setSeed] = useState(0);
  const [guidance, setGuidance] = useState(7.5);
  const [model, setModel] = useState("veo-3");

  const [jobId, setJobId] = useState(null);
  const [status, setStatus] = useState("idle"); // idle | queued | running | done | error
  const [progress, setProgress] = useState(0); // 0..100
  const [error, setError] = useState("");
  const [videoUrl, setVideoUrl] = useState("");
  const [meta, setMeta] = useState(null);

  const canGenerate = apiKey && prompt && status !== "running" && status !== "queued";

  const handleGenerate = useCallback(async () => {
    setError("");
    setStatus("queued");
    setProgress(1);
    setVideoUrl("");
    setMeta(null);

    try {
      const res = await fetch("/api/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          apiKey,
          model,
          prompt,
          negativePrompt,
          durationSeconds: Number(duration),
          aspectRatio: aspect,
          seed: Number(seed) || 0,
          guidanceScale: Number(guidance) || 7.5,
        }),
      });

      if (!res.ok) throw new Error(`Generate failed: ${res.status}`);
      const data = await res.json();
      setJobId(data.jobId);
      setStatus("running");
      setProgress(5);

      // Poll
      let done = false;
      let lastPct = 5;
      while (!done) {
        const s = await fetch(`/api/status/${encodeURIComponent(data.jobId)}`);
        if (!s.ok) throw new Error(`Status failed: ${s.status}`);
        const state = await s.json();
        setStatus(state.status);
        setProgress(state.progress ?? lastPct);
        lastPct = state.progress ?? lastPct;
        setMeta(state.meta || null);
        if (state.status === "done") {
          done = true;
          setProgress(100);
          break;
        }
        if (state.status === "error") {
          throw new Error(state.error || "Unknown job error");
        }
        await sleep(2000);
      }

      const f = await fetch(`/api/file/${encodeURIComponent(data.jobId)}`);
      if (!f.ok) throw new Error(`Download failed: ${f.status}`);
      const blob = await f.blob();
      const url = URL.createObjectURL(blob);
      setVideoUrl(url);
    } catch (e) {
      console.error(e);
      setError(e.message || String(e));
      setStatus("error");
    }
  }, [apiKey, model, prompt, negativePrompt, duration, aspect, seed, guidance]);

  const reset = useCallback(() => {
    setJobId(null);
    setStatus("idle");
    setProgress(0);
    setVideoUrl("");
    setError("");
    setMeta(null);
  }, []);

  return (
    <div className="min-h-screen bg-gradient-to-b from-gray-50 to-white p-6">
      <div className="mx-auto max-w-5xl space-y-6">
        <header className="flex items-center justify-between">
          <h1 className="text-2xl md:text-3xl font-bold">Veo 3 Video Generator</h1>
          <div className="text-sm text-gray-500">Single-file app • API Key ready</div>
        </header>

        <Card>
          <div className="grid md:grid-cols-2 gap-6">
            <div>
              <Label htmlFor="apiKey">API Key</Label>
              <Input
                id="apiKey"
                type="password"
                placeholder="paste your key here"
                value={apiKey}
                onChange={(e) => setApiKey(e.target.value)}
                autoComplete="off"
              />
            </div>
            <div>
              <Label htmlFor="model">Model</Label>
              <Select id="model" value={model} onChange={(e) => setModel(e.target.value)}>
                <option value="veo-3">veo-3</option>
                <option value="veo-3-creative">veo-3-creative</option>
                <option value="veo-3-fast">veo-3-fast</option>
              </Select>
            </div>
            <div className="md:col-span-2">
              <Label htmlFor="prompt">Prompt</Label>
              <Textarea
                id="prompt"
                placeholder="Describe the video you want (Bahasa Indonesia juga bisa)"
                value={prompt}
                onChange={(e) => setPrompt(e.target.value)}
              />
            </div>
            <div className="md:col-span-2">
              <Label htmlFor="negative">Negative Prompt (optional)</Label>
              <Input id="negative" value={negativePrompt} onChange={(e) => setNegativePrompt(e.target.value)} placeholder="things to avoid" />
            </div>
            <div>
              <Label htmlFor="duration">Duration (sec)</Label>
              <Input id="duration" type="number" min={1} max={60} value={duration} onChange={(e) => setDuration(e.target.value)} />
            </div>
            <div>
              <Label htmlFor="aspect">Aspect Ratio</Label>
              <Select id="aspect" value={aspect} onChange={(e) => setAspect(e.target.value)}>
                <option value="9:16">9:16 (Shorts/TikTok)</option>
                <option value="16:9">16:9 (Landscape)</option>
                <option value="1:1">1:1 (Square)</option>
                <option value="4:5">4:5 (Portrait)</option>
              </Select>
            </div>
            <div>
              <Label htmlFor="seed">Seed</Label>
              <Input id="seed" type="number" value={seed} onChange={(e) => setSeed(e.target.value)} />
            </div>
            <div>
              <Label htmlFor="guidance">Guidance Scale</Label>
              <Input id="guidance" type="number" step="0.1" min={1} max={20} value={guidance} onChange={(e) => setGuidance(e.target.value)} />
            </div>
          </div>

          <div className="mt-4 flex items-center gap-3">
            <Button onClick={handleGenerate} disabled={!canGenerate} className={`bg-black text-white ${!canGenerate ? "opacity-50 cursor-not-allowed" : ""}`}>
              {status === "running" || status === "queued" ? "Generating…" : "Generate"}
            </Button>
            <Button onClick={reset} className="bg-white">Reset</Button>
            {error && <span className="text-sm text-red-600">{error}</span>}
          </div>

          <div className="mt-6">
            <div className="h-3 w-full bg-gray-100 rounded-full overflow-hidden">
              <div className="h-full bg-black/80" style={{ width: `${progress}%` }} />
            </div>
            <div className="mt-2 text-sm text-gray-600 flex items-center justify-between">
              <span>Status: {status}</span>
              {meta?.compute && (
                <span>Compute: {meta.compute} • Frames: {meta.frames} • Est: {meta.etaSec}s</span>
              )}
            </div>
          </div>
        </Card>

        <Card>
          <h2 className="text-lg font-semibold mb-3">Result</h2>
          {videoUrl ? (
            <div className="space-y-3">
              <video src={videoUrl} controls className="w-full rounded-2xl" />
              <div className="flex gap-3">
                <a href={videoUrl} download={`veo3_${jobId || "video"}.mp4`}>
                  <Button className="bg-black text-white">Download MP4</Button>
                </a>
                <Button onClick={() => { navigator.clipboard.writeText(prompt); }} className="bg-white">Copy Prompt</Button>
              </div>
            </div>
          ) : (
            <div className="text-sm text-gray-500">No video yet. Fill the form and press Generate.</div>
          )}
        </Card>

        <Card>
          <h3 className="font-semibold mb-2">How to run</h3>
          <ol className="list-decimal ml-5 space-y-1 text-sm text-gray-700">
            <li>Create a new project folder and run <code>npm init -y</code></li>
            <li>Install deps: <code>npm i express node-fetch@3</code></li>
            <li>Create <code>server.js</code> using the code below, then <code>node server.js</code></li>
            <li>Serve this React app with any dev server (Vite/Next) or export to static and proxy to <code>http://localhost:8787</code> (default)</li>
            <li>Paste your API key in the UI. Hit Generate.</li>
          </ol>
        </Card>

        <Card>
          <h3 className="font-semibold mb-2">Backend (server.js)</h3>
          <pre className="whitespace-pre-wrap text-xs bg-gray-50 p-4 rounded-2xl border border-gray-200 overflow-auto">
{`
/**
 * Minimal Veo 3 proxy for browser apps
 * ------------------------------------
 * This Express server receives an API key from the client PER REQUEST and
 * calls your Veo 3 endpoint. Replace the marked TODO with the real call and
 * normalize the response to the unified shapes below.
 *
 * Start:   node server.js
 */

import express from 'express';
import fetch from 'node-fetch';

const app = express();
app.use(express.json({ limit: '2mb' }));

// In-memory job store for demo
const jobs = new Map();

// Util: make a simple random id
const rid = () => Math.random().toString(36).slice(2, 10);

app.post('/api/generate', async (req, res) => {
  try {
    const { apiKey, model = 'veo-3', prompt, negativePrompt, durationSeconds = 5, aspectRatio = '9:16', seed = 0, guidanceScale = 7.5 } = req.body || {};
    if (!apiKey) return res.status(400).json({ error: 'Missing apiKey' });
    if (!prompt) return res.status(400).json({ error: 'Missing prompt' });

    const jobId = rid();
    jobs.set(jobId, { status: 'queued', progress: 1, meta: { frames: 0, etaSec: 20, compute: 'T4-ish' } });

    // Fire-and-forget async job
    (async () => {
      try {
        jobs.set(jobId, { status: 'running', progress: 10, meta: { frames: 0, etaSec: 18, compute: 'T4-ish' } });

        // =====================
        // TODO: Call your Veo 3 endpoint here.
        // Example shape (PSEUDOCODE - replace with real endpoint):
        // const init = await fetch('https://<your-veo-endpoint>', {
        //   method: 'POST',
        //   headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + apiKey },
        //   body: JSON.stringify({ model, prompt, negative_prompt: negativePrompt, duration: durationSeconds, aspect_ratio: aspectRatio, seed, guidance_scale: guidanceScale })
        // });
        // const initJson = await init.json();
        // const remoteJobId = initJson.id;

        // For demo we simulate progression
        let pct = 10;
        for (let i = 0; i < 8; i++) {
          await new Promise((r) => setTimeout(r, 1500));
          pct += 10 + Math.round(Math.random() * 5);
          if (pct > 95) pct = 95;
          jobs.set(jobId, { status: 'running', progress: pct, meta: { frames: 24 * ((i+1) * (durationSeconds/2)), etaSec: Math.max(2, 12 - i*1.2), compute: 'T4-ish' } });
        }

        // When done, you should download the file bytes from the real API
        // and stash them. Here we just generate a tiny MP4 placeholder.
        const placeholder = await makeTinyMP4();
        jobs.set(jobId, { status: 'done', progress: 100, file: placeholder, meta: { frames: 24 * durationSeconds, etaSec: 0, compute: 'T4-ish' } });
      } catch (err) {
        jobs.set(jobId, { status: 'error', progress: 0, error: err?.message || 'job failed' });
      }
    })();

    res.json({ jobId });
  } catch (e) {
    res.status(500).json({ error: e?.message || 'Server error' });
  }
});

app.get('/api/status/:id', (req, res) => {
  const j = jobs.get(req.params.id);
  if (!j) return res.status(404).json({ error: 'not found' });
  const { status, progress, meta, error } = j;
  res.json({ status, progress, meta, error });
});

app.get('/api/file/:id', (req, res) => {
  const j = jobs.get(req.params.id);
  if (!j || j.status !== 'done' || !j.file) return res.status(404).json({ error: 'not ready' });
  res.setHeader('Content-Type', 'video/mp4');
  res.setHeader('Cache-Control', 'no-store');
  res.send(j.file);
});

// --- utils ---
async function makeTinyMP4() {
  // A super tiny 1px mp4 so the UI flow works before you wire the real API.
  // Replace this with the bytes you download from the Veo 3 API.
  const base64 = 'AAAAHGZ0eXBpc28yAAAAAGlzbzJpc28yYXZjMQAAAAhmcmVlAAAAIG1kYXQAAAABAAEAAQABAAAAAQAAAP//AAACAAACAAABAAAAAA==';
  return Buffer.from(base64, 'base64');
}

const PORT = process.env.PORT || 8787;
app.listen(PORT, () => console.log('Veo proxy listening on http://localhost:' + PORT));
`}
          </pre><p className="text-sm text-gray-600 mt-3">
        ⚠️ Replace the <strong>TODO</strong> with the official Veo 3 API call (Vertex AI / Gemini API) when available for your account, then pipe the video bytes to <code>jobs.get(jobId).file</code>.
      </p>
    </Card>

    <footer className="text-xs text-gray-500 text-center pb-6">Made for quick prototyping • Tailwind-ready • No build step required here</footer>
  </div>
</div>

); }

